# 벌칸 접하기 전에 알아두면 좋은 점들


## 이론배경

벌칸은 모던 렌더링 API 스펙이다.

이 스펙은 다양한 하드웨어와 소프트웨어 개발자들이 모여서 합의하여 만들어진 스펙이다. 이를 주관하는 산업체가 바로 The Khronos Group이다.

인스턴스 여러개를 만드는 것 까지 상정하여 초대규모 프로젝트도 능히 감당하도록 설계되어있다. 

대부분의 작은 프로젝트에서는 소잡칼 닭잡칼격이다. 

C를 기반으로 만들어져있으나 다양한 언어의 바인딩을 지원한다.

이밍 규칙

함수는 보통 vk가 앞에 붙는다.\n  타입들은 Vk가 앞에 붙어있다.

Info가 붙은 구조체는 수동으로 초기화해야한다. 수동으로 초기화할 구조체 앞에는 sType, pNext, flags가 들어간다.

sType은 해당 구조체가 무엇인지 알려주기 위해 VK_STRUCTURE_TYPE으로 시작하는 상수를 넣어줘야 한다. 이렇게 만들어진 이유는 벌칸 구현체가 궁극적으로는 포인터만 받고 타입은 컴파일 시점에 사라지기에 표준화를 위해 어쩔 수 없는 C스타일 문법이다. 

pNext는 거의 대부분 null을 넣어주면 된다. 어쩌다 가끔 EXT로 끝나는 구조체를 넣어주는 경우가 있다. 익스텐션을 위해 존재한다.

flags는 거의 대부분 0을 넣는다.
다만 필요한 경우 특정 플레그랑 or연산을 통해서 특정 기능을 활성화   하는걸 알려야할 때도 있다 (대표적으로 메모리 할당 때)  

## 구조

벌칸 로더 밑에는 드라이버와 레이어가 있고 벌칸 로더에는 익스텐션이 존재할 수 있다.

레이어는 코드 수정 없이도 벌칸과 드라이버 사이에 들어가 특정 기능을 수행하는 역할을 한다.

익스텐션은 제조사들이 만들고 크로노스그룹과 협업하여 벌칸에 추가하는 확장들이다. 이들은 딱 봐도 확장에서 추가된 것이라는걸 알기 쉽게 NV, KHR, EXT, MVK같은 키워드가 이름에 포함되어있다.

익스텐션은 레이어랑 다르게 코딩단에서 사용 여부를 결정해야한다.

 
벌칸은 오브젝트 기반으로 만들어져있다. 비록 C지만 객체지향 페러다임의 사고방식을 상당히 인용한다.

객체엔 크게 세가지 종류가 있다.
  
* **투명타입**:

	벌칸이 당신에게 알려줄게 있을 때 사용되는 타입이다. 예를 들어서 VkPhysicalDeviceLimits 같은 타입은 드라이버의 최대/최소 스펙을 보여준다. 프로그래머가 만들일은 없고 get함수나 enumerate함수로 갖고오게 된다.
  
* **불투명타입**:

	vkCreate함수로 만들어진 벌칸의 고유 타입이다. 이들은 포인터와 선언만 있을 뿐 메모리상에 어떤 데이터를 갖고 있을지는 드라이버 구현자들만 알고있다. instance, device, queue 등이 해당된다. 불투명 타입들은 프로그램이 종료될 때 vkDestroy 해줘야하는 경우가 많다.
  
* **인포(Info) 구조체**:

	당신이 벌칸에게 알려줄게 있을 때 사용되는 타입이다. 앞서 설명한 sType, pNext, flags가 있는 구조체들이 여기에 해당된다. 거의 대부분 불투명 타입을 생성하는 VkCreate류 함수들에서 호출된다.


벌칸은 큰 틀에서 다음과같은 구조를 갖고 있다. 각 구조들은 여러개 생성이 가능한걸 상정하여 만들어져서 필요하다면 여러개 만들어도 무방하다. 거대한 프로젝트에서는 인스턴스조차 여러개 만드는 경우도 있다.
  
인스턴스: 피지컬 디바이스, 앱 인포와 같이 외적 정보를 담고있다.

물리 장치: 실질적으로 존재하는 물리적 장치들을 가르킨다. 수동으로 생성하지 않고 enumerate한다.
  
논리 장치: device라고 불리는 논리적 장치다. 하나의 물리장치에 여러 디바이스를 만들 수도 있긴 하다.
  
  큐: 논리장치가 갖고있는 명령을 받는 큐다. 큐는 네가지 기능 중 하나 이상의 기능을 하도록 하드웨어적으로 이미 만들어져있다.

##

제출과 동기화  벌칸은 아예 처음부터 장치와 호스트(CPU, RAM)간의 통신과 그에 필요한 도구들만 재공할 뿐 그 과정을 구현하는 것은 어플리케이션 에게 모든 책임과 권한을 준다. 따라서 컴퓨터공학적인 동기화 메커니즘을 지원한다.


벌칸이 어떠한 명령을 배열처럼 기록하는 개체를 CommandBuffer 이라고 부른다(별칭 커멘드 버퍼).


커멘드 버퍼에 기록된 명령은 큐에 제출되면 실행된다.

제출되면 드라이버는 그것을 처리해내려고 최대한 노력한다.

제출만 되면 즉시 처리되기에 호스트와 디바이스는 비동기적이다.

따라서 최소한의 동기화 메커니즘은 필요하다.

* **Fence**: 디바이스가 일을 완료할 때 까지 이 함수에서 멈춰있게 된다.

* **Semaphore**: 철학자들의 만찬문제에서 나오는 그 세마포어 맞다. 다만 벌칸의 세마포어는 큐와 큐 사이를 동기화 하는데 사용된다.

* **파이프라인 베리어**: 같은 큐 안에서 종속성(즉, 순서)를 정해주는데 사용 된다. 매우 중요한 개념이지만 숙련된 프로그래머들도 쉽사리 익숙해지는데 어려움을 겪는 개념이다. 엄밀하게 말해서 동기화 메커니즘보단 작업 순서를 정리하는 것에 가까운 개념이다.

* **Event**: 제출되기 전 커멘드버퍼 사이를 동기화할 수 있다.
 사용 사례는 적은 편이다.
 
 
 
파이프라인과 셰이더 그리고 SPIR-V  파이프라인은 OpenGL 초기에도 있던 원리고 소프트웨어 렌더러를 직접 만들어 실습해본 이들은 누구나 아는 개념이다.


 벌칸도 파이프라인을 사용하며 당연히 프로그래밍 가능한 파이프라인이다. 벌칸 파이프라인은 컴퓨트 파이프라인, 그래픽스 파이프라인이 있다. 더 나아가 파이프라인을 여러개 만들어둘 수도 있다. 당연히 각자 다른 셰이더와 설정을 할 수 있다.

 컴퓨팅도 마찬가지라서 파이프라인 사용이 매우 용이하다. 컴퓨팅 파이프라인은 그래픽 파이프라인과 병행이 가능하다.
 
다만 파이프라인을 만드는 과정이 다소 불편하다.

파이프라인의 각 스테이지별로 설정을 해줘야할게 조금 있다. 그래도 조작 못하게 막아둔 것보다는 낫다.

파이프라인에 들어갈 셰이더도 조금 새로워졌다. 이제 더이상 드라이버가 런타임에서 섀이더를 컴파일해주지 않는다(그런데 해주는 유틸리티는 존재한다). 그 대신 미리 컴파일된 섀이더를 불러올 수가 있다. 유감이지만 불러올 때는 c표준 입출력으로 읽어와야한다. 

이렇게 미리 컴파일된 섀이더 언어를 SPIR-V라고 부른다. 여러분이 Vulkan sdk를 설치하면 glslc라는 컴파일러가 생길탠데 이것이 GLSL 셰이더를 SPIR-V로 컴파일해주는 도구다.

현재는 공식적으로 Metal, HLSL, GLSL을 지원한다.

컴파일된 중간단계 언어는 벌칸에서만 사용되지 않는다. 원한다면 OpenCL에서도 사용할 수 있다. 중간단계 언어를 읽어봄으로서 마치 디스어셈블리를 하듯 내가 만든 셰이더가 정확히 무슨짓을 하는지도 알 수 있다(다만 메모장으로는 안된다).

게다가 이 중간단계 언어를 DXIL로 컴파일하면 다이렉트 12에서도 사용할 수 있다. 이러한 중간언어의 존재 덕분에 SPIR-V는 매우 훌륭한 파이프라인 프로그래밍 도구가 되어준다. 파일 형식은 spv이다.


glslc는 .frag, .vert같은 셰이더 파일을 불러와서 컴파일해준다.

## 마치며 

결국 벌칸의 메커니즘은 API를 얇게 만들고 드라이버의 잘못을 최소화 하는 것에 초점이 맞춰져있다. 또한 객체지향 페러다임을 인용하여 저수준 언어에서도 포인터 변수를 통해 조작하도록 해주는 구조로 되어있다. 벌칸엔 하드웨어적인 지식을 요구하는 내용이 많다. 가능한 한 자신의 그래픽카드 아키텍쳐에 해당된 백서는 읽어보는 것이 좋다.

벌칸은 궁극적으로 누구에게나 구현의 길을 열어두고 있다. 만약 여러분이 드라이버를 개발한다면 호출이 아닌 구현자로서 벌칸을 다룰지도 모른다.

## 

참고자료  - [한국 블로거](https://lifeisforu.tistory.com/category/Vulkan%20%26%20OpenGL)  
- [공식 스펙](https://registry.khronos.org/vulkan)  
- [벌칸 공식 유튜브](https://www.youtube.com/@Vulkan)  
- [크로노스그룹 공식 유튜브](https://www.youtube.com/@khronos)  
- [공식 가이드북(별칭 페라리책)](https://product.kyobobook.co.kr/detail/S000000935996)  
- [유튜버 The Cherno](https://www.youtube.com/@TheCherno/featured)
- [온라인 튜토리얼](https://vkguide.dev/)
- [엔비디아의 벌칸 예제](https://github.com/nvpro-samples/build_all)
- [크로노스 그룹 벌칸 예제](https://github.com/KhronosGroup/Vulkan-Samples.git)

엔비디아 벌칸을 빌드하는 방법:

- 일단 build_all을 풀한다
- build_all 바로 옆에다 [github](https://github.com/nvpro-samples/nvpro_core.git) 를 풀한다.
- build_all에 clone_all을 실행한다
- 이제 바로 윗 폴더에 필요한 예제들이 다 들어와있을 것이다.
- cmake -G ”Ninja” -S . -B <빌드폴더가 있을 경로>

크로노스 그룹 벌칸 예제 빌드하는 방법:
- git clone --recurse-submodules https://github.com/KhronosGroup/Vulkan-Samples.git  
- 명령어로 하위 모듈까지 클론.
- cd Vulkan-Samples	
- mkdir build
- cmake -G ”Ninja” -S . -B build
- 비주얼 스튜디오 사용자들은 Ninja를 “Visual Studio 17 2022”로 할 수도 있다.

- [벌칸 공식 스펙문서](https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html)

- [C++ 방식 예제](https://github.com/nvpro-samples/vk_minimal_latest.git)

- [미니멀 예제 C방식](https://github.com/elecro/vkdemos.git)

- [인텔 튜토리얼](https://www.intel.com/content/www/us/en/developer/articles/training/api-without-secrets-introduction-to-vulkan-part-1.html)

## cmake 관련

-G 제너레이터 선택
```
Xcode
Visual Studio 17 2022
Ninja
Make
```

-D 명령줄 인수로 전달할 내용
```
-DUSE_FEATURE_X=ON/OFF
```

-S CMakeLists.txt의 위치

-B cmake가 생성한 결과물의 위치

CMakeLists.txt에서 모든 내장 변수들 확인하기
```
foreach (_variableName VARIABLES)
    message(STATUS "${_variableName}=${ ${_variableName} }")
endforeach()
```


